###############################################################################
#
# IAR C/C++ Compiler V7.10.1.973/W32 for MSP430           03/Aug/2021  16:28:12
# Copyright 1996-2017 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for Texas Instruments MSP430
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  large
#    __code_model  =  large
#    Source file   =  D:\Dev\Project\TI_Car\HardWare\nrf24l01\nrf2401.c
#    Command line  =  
#        -f C:\Users\Jeans\AppData\Local\Temp\EW328E.tmp
#        (D:\Dev\Project\TI_Car\HardWare\nrf24l01\nrf2401.c -D NDEBUG -D
#        RAM_VECTOR -lC D:\Dev\Project\TI_Car\Release\List -lA
#        D:\Dev\Project\TI_Car\Release\List -o
#        D:\Dev\Project\TI_Car\Release\Obj --debug -D__MSP430F5529__ -e
#        --double=32 --dlib_config D:\Dev\IAR\430\lib\dlib\dl430xllfn.h -I
#        D:\Dev\Project\TI_Car\ -I D:\Dev\Project\TI_Car\Drivers\inc\ -I
#        D:\Dev\Project\TI_Car\Drivers\src\ -I D:\Dev\Project\TI_Car\HardWare\
#        -I D:\Dev\Project\TI_Car\HardWare\led\ -I
#        D:\Dev\Project\TI_Car\HardWare\key\ -I
#        D:\Dev\Project\TI_Car\HardWare\lcd\ -I
#        D:\Dev\Project\TI_Car\HardWare\lcd_api\ -I
#        D:\Dev\Project\TI_Car\HardWare\nrf24l01\ -I
#        D:\Dev\Project\TI_Car\HardWare\oled\ -I
#        D:\Dev\Project\TI_Car\HardWare\delay\ -I
#        D:\Dev\Project\TI_Car\HardWare\2.2TFT\ -I
#        D:\Dev\Project\TI_Car\System\ -I D:\Dev\Project\TI_Car\System\inc\ -I
#        D:\Dev\Project\TI_Car\System\src\ -I D:\Dev\Project\TI_Car\User\ -I
#        D:\Dev\Project\TI_Car\User\USER\ -I
#        D:\Dev\Project\TI_Car\HardWare\motor\ -I D:\Dev\Project\TI_Car\User\
#        -I D:\Dev\Project\TI_Car\HardWare\encoder\ --core=430X
#        --data_model=large -Oh --multiplier=32 --hw_workaround=CPU40
#        --hw_workaround=nop_after_lpm -DNDEBUG --code_model=large)
#    Locale        =  Chinese (Simplified)_CHN.936
#    List file     =  D:\Dev\Project\TI_Car\Release\List\nrf2401.lst
#    Object file   =  D:\Dev\Project\TI_Car\Release\Obj\nrf2401.r43
#
###############################################################################

D:\Dev\Project\TI_Car\HardWare\nrf24l01\nrf2401.c
      1          #include "nrf2401.H"

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> __data16 _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x262
   \   union <unnamed> __data16 _A_PDOUT_L
   \                     _A_PDOUT_L:
   \   000000                DS8 2
      2          //********************************************************************************************************************// 
      3          // SPI(nRF24L01) 指令
      4          #define READ_REG    0x00   // 读配置寄存器
      5          #define WRITE_REG   0x20   // 写配置寄存器
      6          #define RD_RX_PLOAD 0x61   // 读取RX FIFO中的数据
      7          #define WR_TX_PLOAD 0xA0   // 向TX FIFO中写入数据
      8          #define FLUSH_TX    0xE1   // 清除TX FIFO中的数据 应用于发射模式下
      9          #define FLUSH_RX    0xE2   // 清除RX FIFO中的数据 应用于接收模式下
     10          #define REUSE_TX_PL 0xE3   // 重新使用上一包有效数据
     11          #define NOP         0xFF   // 保留
     12          //********************************************************************************************************************// 
     13          // SPI(nRF24L01) 寄存器(地址)
     14          #define CONFIG      0x00  //配置发送状态，CRC校验模式以及发收发状态响应方式
     15          
     16          #define MASK_RX_DR  BIT6  //可屏蔽中断-接收中断 1：屏蔽中断
     17          #define MASK_TX_DS  BIT5  //可屏蔽中断-发送完成中断
     18          #define MASK_MAX_RT BIT4  //可屏蔽中断-达到最大重发次数中断
     19          #define EN_CRC      BIT3  //使能CRC
     20          #define CRCO        BIT2  //0：CRC8位: 1：16位
     21          #define PWR_UP      BIT1  //1：上电 0：掉电
     22          #define PRIM_RX     BIT0  //1：接收模式 0：发射模式
     23          
     24          #define EN_AA       0x01  //自动应答功能设置
     25          #define EN_RXADDR   0x02  //可用信道设置
     26          #define SETUP_AW    0x03  //收发地址宽度设置
     27          #define SETUP_RETR  0x04  //自动重发功能设设置
     28          #define RF_CH       0x05  //工作频率设定
     29          #define RF_SETUP    0x06  //
     30          #define STATUS      0x07  //
     31          #define OBSERVE_TX  0x08  //
     32          #define CD          0x09  //
     33          #define RX_ADDR_P0  0x0A
     34          #define RX_ADDR_P1  0x0B
     35          #define RX_ADDR_P2  0x0C
     36          #define RX_ADDR_P3  0x0D
     37          #define RX_ADDR_P4  0x0E
     38          #define RX_ADDR_P5  0x0F
     39          #define TX_ADDR     0x10
     40          #define RX_PW_P0    0x11
     41          #define RX_PW_P1    0x12
     42          #define RX_PW_P2    0x13
     43          #define RX_PW_P3    0x14
     44          #define RX_PW_P4    0x15
     45          #define RX_PW_P5    0x16
     46          #define FIFO_STATUS 0x17
     47          
     48          //几个重要的状态标记
     49          #define STATUS_TX_FULL     0x01        //TX FIFO 寄存器满标志。 1 为 满，0为 不满
     50          #define STATUS_MAX_RT      0x10        //达到最大重发次数中断标志位
     51          #define STATUS_TX_DS       0x20        //发送完成中断标志位
     52          #define STATUS_RX_DR       0x40        //接收到数据中断标志位
     53          

   \                                 In  segment DATA20_C, align 1, align-sorted
     54          const uint8_t TX_ADDRESS[TX_ADR_WIDTH]={0xE1,0xE2,0xE3,0xE4,0xE5}; //发送地址
   \                     TX_ADDRESS:
   \   000000   E1E2E3E4E5   DC8 225, 226, 227, 228, 229

   \                                 In  segment DATA20_C, align 1, align-sorted
     55          const uint8_t RX_ADDRESS[RX_ADR_WIDTH]={0xE1,0xE2,0xE3,0xE4,0xE5}; //接收地址
   \                     RX_ADDRESS:
   \   000000   E1E2E3E4E5   DC8 225, 226, 227, 228, 229
     56          

   \                                 In  segment DATA20_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero20
     57          static s_NRF24L01 s_nrf24l01;
   \                     s_nrf24l01:
   \   000000                DS8 24
     58          /***********************************************************************************************
     59           功能：NRF24L01 读写一个字节
     60           形参：发送的数据
     61           返回：读到的数据
     62           详解：调用SPI模块
     63          ************************************************************************************************/
     64          static uint8_t NRF2401_ReadWriteByte(uint8_t data)
     65          {
     66          #if NRF24L01HardWareSPI
     67            return NRF2401HardWareSPI_SendByte(data);   //发送并读取一字节数据
     68          #else
     69            for(uint8_t i=0;i < 8;i++)          // 循环8次
     70            {
     71              NRF2401_SIMO = (data&0x80) ? 1 : 0;//上升沿发送数据// byte最高位输出到MOSI
     72              data <<= 1;             // 低一位移位到最高位
     73              NRF2401_SCL = 1; 
     74              if(NRF2401_SOMI)            // 拉高SCK，nRF24L01从MOSI读入1位数据，同时从MISO输出1位数据
     75                data |= 0x01;       	// 读MISO到byte最低位
     76              NRF2401_SCL = 0;            	// SCK置低
     77            }
     78            return(data);           	// 返回读出的一字节
     79          #endif
     80          }
     81          /***********************************************************************************************
     82           功能：NRF24L01 写寄存器
     83           形参：reg: 寄存器
     84                 value:写入的值
     85           返回：读到的数据
     86           详解：无
     87          ************************************************************************************************/

   \                                 In  segment CODE, align 2
     88          static uint8_t NRF2401_ReadWriteReg(uint8_t reg,uint8_t value)
   \                     NRF2401_ReadWriteReg:
     89          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   4A4D         MOV.B   R13, R10
     90          	NRF2401_CSN = 0;                   // CSN low, init SPI transaction
   \   000004   E2C26302     BIC.B   #0x4, &0x263
     91          	uint8_t status = NRF2401_ReadWriteByte(reg);      // select register
   \   000008   4D4C         MOV.B   R12, R13
   \   00000A   ........     CALLA   #?Subroutine3
   \                     ??CrossCallReturnLabel_4:
   \   00000E   4B4C         MOV.B   R12, R11
     92          	NRF2401_ReadWriteByte(value);             // ..and write value to it..
   \   000010   4D4A         MOV.B   R10, R13
   \   000012   ........     CALLA   #?Subroutine3
     93          	NRF2401_CSN = 1;                   // CSN high again
   \                     ??CrossCallReturnLabel_3:
   \   000016   E2D26302     BIS.B   #0x4, &0x263
     94          	return(status);            // return nRF24L01 status byte
   \   00001A   4C4B         MOV.B   R11, R12
   \   00001C   1A16         POPM.A  #0x2, R11
   \   00001E   1001         RETA
   \   000020                REQUIRE _A_PDOUT_L
     95          }
     96          /***********************************************************************************************
     97           功能：NRF24L01 写寄存器
     98           形参：reg: 寄存器
     99                 value:写入的值
    100           返回：读到的数据
    101           详解：无
    102          ************************************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    103          static uint8_t NRF2401_WriteBuffer(uint8_t reg,uint8_t *pBuf,uint8_t bytes)
   \                     NRF2401_WriteBuffer:
    104          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   ........     CALLA   #?Subroutine2
    105          	NRF2401_CSN = 0; 
    106          	uint8_t status = NRF2401_ReadWriteByte(reg);    // Select register to write to and read status byte
    107          	for(uint8_t i=0; i<bytes; i++) // then write all byte in buffer(*pBuf)
   \                     ??CrossCallReturnLabel_0:
   \   000006   0524         JEQ     ??NRF2401_WriteBuffer_1
    108          	{
    109          		NRF2401_ReadWriteByte(*pBuf++);
   \                     ??NRF2401_WriteBuffer_0:
   \   000008   7D4B         MOV.B   @R11+, R13
   \   00000A   ........     CALLA   #?Subroutine3
    110          	}
   \                     ??CrossCallReturnLabel_2:
   \   00000E   7A53         ADD.B   #0xff, R10
   \   000010   FB23         JNE     ??NRF2401_WriteBuffer_0
    111          	NRF2401_CSN = 1;                 // Set CSN high again
   \                     ??NRF2401_WriteBuffer_1:
   \   000012                REQUIRE ?Subroutine1
   \   000012                REQUIRE _A_PDOUT_L
   \   000012                // Fall through to label ?Subroutine1
    112          	return(status);          // return nRF24L01 status byte
    113          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine1:
   \   000000   E2D26302     BIS.B   #0x4, &0x263
   \   000004   4C48         MOV.B   R8, R12
   \   000006   3816         POPM.A  #0x4, R11
   \   000008   1001         RETA

   \                                 In  segment CODE, align 2
   \                     ?Subroutine2:
   \   000000   CB0D         MOVA    R13, R11
   \   000002   4A4E         MOV.B   R14, R10
   \   000004   E2C26302     BIC.B   #0x4, &0x263
   \   000008   4D4C         MOV.B   R12, R13
   \   00000A   7C400300     MOV.B   #0x3, R12
   \   00000E   ........     CALLA   #SPI_SendReadByte
   \   000012   484C         MOV.B   R12, R8
   \   000014   4A93         CMP.B   #0x0, R10
   \   000016   1001         RETA
    114          /***********************************************************************************************
    115           功能：NRF24L01 读Buffer
    116           形参：reg: 寄存器
    117                 pBuf:数据指针
    118          		 	 bytes: 写入的字节数
    119           返回：读状态
    120           详解：无
    121          ************************************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine3:
   \   000000   7C400300     MOV.B   #0x3, R12
   \   000004   ........     BRA     #SPI_SendReadByte

   \                                 In  segment CODE, align 2
    122          static uint8_t NRF2401_ReadBuffer(uint8_t reg,uint8_t *pBuf,uint8_t bytes)
   \                     NRF2401_ReadBuffer:
    123          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   ........     CALLA   #?Subroutine2
    124          	NRF2401_CSN = 0;                    		// Set CSN low, init SPI tranaction
    125          	uint8_t status = NRF2401_ReadWriteByte(reg);       		// Select register to write to and read status byte
    126          	for(uint8_t i=0;i<bytes;i++)
   \                     ??CrossCallReturnLabel_1:
   \   000006   0924         JEQ     ??NRF2401_ReadBuffer_1
    127          	{
    128          		pBuf[i] = NRF2401_ReadWriteByte(0);    // Perform SPI_RW to read byte from nRF24L01
   \                     ??NRF2401_ReadBuffer_0:
   \   000008   4D43         MOV.B   #0x0, R13
   \   00000A   ........     CALLA   #?Subroutine3
    129          	}
   \                     ??CrossCallReturnLabel_5:
   \   00000E   CB4C0000     MOV.B   R12, 0(R11)
   \   000012   AB000100     ADDA    #0x1, R11
   \   000016   7A53         ADD.B   #0xff, R10
   \   000018   F723         JNE     ??NRF2401_ReadBuffer_0
    130          	NRF2401_CSN = 1;                           // Set CSN high again
   \                     ??NRF2401_ReadBuffer_1:
   \   00001A   ....         JMP     ?Subroutine1
   \   00001C   0343         NOP
   \   00001E                REQUIRE _A_PDOUT_L
    131          	return(status);                    // return nRF24L01 status byte
    132          }
    133          
    134          /***********************************************************************************************
    135           功能：检测NRF24L01 是否存在
    136           形参：
    137           返回：NRF_OK : 成功   NRF_ERR:失败
    138           详解：无
    139          ************************************************************************************************/
    140          static uint8_t NRF24L01_Check(void)
    141          {
    142          	uint8_t buf[5]={0XA5,0XA5,0XA5,0XA5,0XA5};
    143          	NRF2401_WriteBuffer(WRITE_REG+TX_ADDR,buf,5);//写入5个字节的地址.	
    144          	NRF2401_ReadBuffer(TX_ADDR,buf,5); //读出写入的地址  
    145          	for(uint8_t i=0;i < 5;i++)
    146          	{
    147          		if(buf[i] != 0xA5) return NRF_ERR;
    148          	}
    149          	return NRF_OK;
    150          /*******************************************************************************
    151          *  函数名称：
    152          *  功能说明：NRF24L01初始化
    153          *  参数说明：
    154          *  函数返回：
    155          *  使用示例：
    156          ********************************************************************************/}

   \                                 In  segment CODE, align 2
    157          uint8_t NRF2401_Init(s_NRF24L01 nrf24l01)
   \                     NRF2401_Init:
    158          {
   \   000000   3B14         PUSHM.A #0x4, R11
   \   000002   B1000600     SUBA    #0x6, SP
    159                  s_nrf24l01 = nrf24l01;
   \   000006   ........     MOVA    #s_nrf24l01, R12
   \   00000A   CE01         MOVA    SP, R14
   \   00000C   AE001A00     ADDA    #0x1a, R14
   \   000010   8D000C00     MOVA    #0xc, R13
   \   000014   ........     CALLA   #?CopyMemoryWords20
    160                  
    161                  GPIO_Init(NRF2401_CE_PORT,NRF2401_CE_PIN,GPO);
   \   000018   2E43         MOV.W   #0x2, R14
   \   00001A   3D408000     MOV.W   #0x80, R13
   \   00001E   6C43         MOV.B   #0x2, R12
   \   000020   ........     CALLA   #GPIO_MultiBits_Init
    162                  GPIO_Init(NRF2401_CSN_PORT,NRF2401_CSN_PIN,GPO);
   \   000024   2E43         MOV.W   #0x2, R14
   \   000026   2D42         MOV.W   #0x4, R13
   \   000028   7C400700     MOV.B   #0x7, R12
   \   00002C   ........     CALLA   #GPIO_MultiBits_Init
    163                  //GPIO_Init(NRF2401_IRQ_PORT,NRF2401_IRQ_PIN,GPI);
    164                  
    165                  nrf24l01.CallBack_IRQ_Init();
   \   000030   3F011E00     MOVA    0x1e(SP), R15
   \   000034   4F13         CALLA   R15
    166          #if NRF24L01HardWareSPI
    167                  NRF2401HardWareSPI_Init();
   \   000036   6312         PUSH.B  #0x2
   \   000038   4312         PUSH.B  #0x0
   \   00003A   5D43         MOV.B   #0x1, R13
   \   00003C   3E40404B     MOV.W   #0x4b40, R14
   \   000040   3F404C00     MOV.W   #0x4c, R15
   \   000044   7C400300     MOV.B   #0x3, R12
   \   000048   ........     CALLA   #SPI_Master_Init
    168          #else
    169                  GPIO_Init(NRF2401_SCL_PORT,NRF2401_SCL_PIN,GPO);
    170                  GPIO_Init(NRF2401_SIMO_PORT,NRF2401_SIMO_PIN,GPO);
    171                  GPIO_Init(NRF2401_SOMI_PORT,NRF2401_SOMI_PIN,GPI);
    172          #endif
    173                  
    174          	NRF2401_CSN = 1;			// Spi disable	
   \   00004C   E2D26302     BIS.B   #0x4, &0x263
    175                  NRF2401_CE = 0;			        // chip enable
   \   000050   ........     CALLA   #?Subroutine5
    176                  //检测NRF2401 是否存在
    177                  uint8_t checkStatus = NRF24L01_Check();
   \                     ??CrossCallReturnLabel_6:
   \   000054   ........     MOVA    #`?<Constant {165, 165, 165, 165, 165}>`, R15
   \   000058   F14F0400     MOV.B   @R15+, 0x4(SP)
   \   00005C   F14F0500     MOV.B   @R15+, 0x5(SP)
   \   000060   F14F0600     MOV.B   @R15+, 0x6(SP)
   \   000064   F14F0700     MOV.B   @R15+, 0x7(SP)
   \   000068   F14F0800     MOV.B   @R15+, 0x8(SP)
   \   00006C   7A400500     MOV.B   #0x5, R10
   \   000070   4E4A         MOV.B   R10, R14
   \   000072   CD01         MOVA    SP, R13
   \   000074   AD000400     ADDA    #0x4, R13
   \   000078   7C403000     MOV.B   #0x30, R12
   \   00007C   ........     CALLA   #NRF2401_WriteBuffer
   \   000080   4E4A         MOV.B   R10, R14
   \   000082   CD01         MOVA    SP, R13
   \   000084   AD000400     ADDA    #0x4, R13
   \   000088   7C401000     MOV.B   #0x10, R12
   \   00008C   ........     CALLA   #NRF2401_ReadBuffer
   \   000090   7E40A500     MOV.B   #0xa5, R14
   \   000094   A1000400     ADDA    #0x4, SP
   \   000098   6E91         CMP.B   @SP, R14
   \   00009A   4920         JNE     ??NRF2401_Init_1
   \   00009C   5E910100     CMP.B   0x1(SP), R14
   \   0000A0   4620         JNE     ??NRF2401_Init_1
   \   0000A2   5E910200     CMP.B   0x2(SP), R14
   \   0000A6   4320         JNE     ??NRF2401_Init_1
   \   0000A8   5E910300     CMP.B   0x3(SP), R14
   \   0000AC   4020         JNE     ??NRF2401_Init_1
   \   0000AE   5E910400     CMP.B   0x4(SP), R14
   \   0000B2   3D20         JNE     ??NRF2401_Init_1
   \   0000B4   4B43         MOV.B   #0x0, R11
    178                  if(checkStatus == NRF_OK)
    179                  {
    180                    NRF2401_CE=0;
   \   0000B6   ........     CALLA   #?Subroutine5
    181                    
    182                    NRF2401_ReadWriteReg(WRITE_REG+SETUP_AW, ADR_WIDTH - 2);          //设置地址长度为 TX_ADR_WIDTH   	    
   \                     ??CrossCallReturnLabel_7:
   \   0000BA   ........     MOVA    #NRF2401_ReadWriteReg, R8
   \   0000BE   7D400300     MOV.B   #0x3, R13
   \   0000C2   7C402300     MOV.B   #0x23, R12
   \   0000C6   4813         CALLA   R8
    183                    NRF2401_WriteBuffer(WRITE_REG+TX_ADDR,(uint8_t*)TX_ADDRESS,TX_ADR_WIDTH);//写TX节点地址 
   \   0000C8   4E4A         MOV.B   R10, R14
   \   0000CA   ........     MOVA    #TX_ADDRESS, R13
   \   0000CE   7C403000     MOV.B   #0x30, R12
   \   0000D2   ........     CALLA   #NRF2401_WriteBuffer
    184                    NRF2401_WriteBuffer(WRITE_REG+RX_ADDR_P0,(uint8_t*)RX_ADDRESS,RX_ADR_WIDTH); //设置TX节点地址,主要为了使能ACK	  
   \   0000D6   4E4A         MOV.B   R10, R14
   \   0000D8   ........     MOVA    #RX_ADDRESS, R13
   \   0000DC   7C402A00     MOV.B   #0x2a, R12
   \   0000E0   ........     CALLA   #NRF2401_WriteBuffer
    185                    NRF2401_ReadWriteReg(WRITE_REG+EN_AA,0x01);     //使能通道0的自动应答    
   \   0000E4   5D43         MOV.B   #0x1, R13
   \   0000E6   7C402100     MOV.B   #0x21, R12
   \   0000EA   4813         CALLA   R8
    186                    NRF2401_ReadWriteReg(WRITE_REG+EN_RXADDR,0x01); //使能通道0的接收地址  
   \   0000EC   5D43         MOV.B   #0x1, R13
   \   0000EE   7C402200     MOV.B   #0x22, R12
   \   0000F2   4813         CALLA   R8
    187                    NRF2401_ReadWriteReg(WRITE_REG+RX_PW_P0,RX_PLOAD_WIDTH);//选择通道0的有效数据宽度
   \   0000F4   7D402000     MOV.B   #0x20, R13
   \   0000F8   7C403100     MOV.B   #0x31, R12
   \   0000FC   4813         CALLA   R8
    188                    NRF2401_ReadWriteReg(WRITE_REG+SETUP_RETR,0x1a);//设置自动重发间隔时间:500us + 86us;最大自动重发次数:10次
   \   0000FE   7D401A00     MOV.B   #0x1a, R13
   \   000102   7C402400     MOV.B   #0x24, R12
   \   000106   4813         CALLA   R8
    189                    NRF2401_ReadWriteReg(WRITE_REG+RF_CH,40);       //设置RF通道为40
   \   000108   7D402800     MOV.B   #0x28, R13
   \   00010C   7C402500     MOV.B   #0x25, R12
   \   000110   4813         CALLA   R8
    190                    NRF2401_ReadWriteReg(WRITE_REG+RF_SETUP,0x0f);  //设置TX发射参数,0db增益,2Mbps,低噪声增益开启
   \   000112   7D400F00     MOV.B   #0xf, R13
   \   000116   7C402600     MOV.B   #0x26, R12
   \   00011A   4813         CALLA   R8
    191                    NRF2401_ReadWriteReg(WRITE_REG+CONFIG,0x0e);     //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式,开启所有中断
   \   00011C   7D400E00     MOV.B   #0xe, R13
   \   000120   7C402000     MOV.B   #0x20, R12
   \   000124   4813         CALLA   R8
    192          
    193                    NRF2401_CE=1;//CE为高,10us后启动发送
   \   000126   F2D080002202 BIS.B   #0x80, &0x222
   \   00012C   013C         JMP     ??NRF2401_Init_0
    194                  }
   \                     ??NRF2401_Init_1:
   \   00012E   5B43         MOV.B   #0x1, R11
    195          	return checkStatus;
   \                     ??NRF2401_Init_0:
   \   000130   4C4B         MOV.B   R11, R12
   \   000132   A1000600     ADDA    #0x6, SP
   \   000136   3816         POPM.A  #0x4, R11
   \   000138   1001         RETA
   \   00013A                REQUIRE _A_PDOUT_L
   \   00013A                REQUIRE _A_PBOUT_L
    196          }

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine5:
   \   000000   F2C080002202 BIC.B   #0x80, &0x222
   \   000006   1001         RETA
    197          /*******************************************************************************
    198          *  函数名称：
    199          *  功能说明：该函数初始化NRF24L01到RX模式
    200                       设置RX地址,写RX数据宽度,选择RF频道,波特率和LNA HCURR
    201                       当CE变高后,即进入RX模式,并可以接收数据了
    202          *  参数说明：
    203          *  函数返回：
    204          *  使用示例：
    205          ********************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    206          void NRF2401_SetRXMode(void)
   \                     NRF2401_SetRXMode:
    207          {
    208          	NRF2401_CE=0;
   \   000000   ........     CALLA   #?Subroutine5
    209             
    210          	NRF2401_ReadWriteReg(WRITE_REG+CONFIG, 0x0f);//配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式
   \                     ??CrossCallReturnLabel_8:
   \   000004   7D400F00     MOV.B   #0xf, R13
   \   000008                REQUIRE ?Subroutine0
   \   000008                REQUIRE _A_PBOUT_L
   \   000008                // Fall through to label ?Subroutine0
    211                  
    212          	NRF2401_CE = 1; //CE为高,进入接收模式
    213          }	

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine0:
   \   000000   7C402000     MOV.B   #0x20, R12
   \   000004                REQUIRE ??Subroutine6_0
   \   000004                // Fall through to label ??Subroutine6_0

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ??Subroutine6_0:
   \   000000   ........     CALLA   #NRF2401_ReadWriteReg
   \   000004   F2D080002202 BIS.B   #0x80, &0x222
   \   00000A   1001         RETA
    214          /*******************************************************************************
    215          *  函数名称：
    216          *  功能说明：该函数初始化NRF24L01到TX模式
    217                       设置TX地址,写TX数据宽度,设置RX自动应答的地址,填充TX发送数据,选择RF频道,波特率和LNA HCURR
    218                       PWR_UP,CRC使能
    219                       当CE变高后,即进入RX模式,并可以接收数据了		   
    220                       CE为高大于10us,则启动发送.	
    221          *  参数说明：
    222          *  函数返回：
    223          *  使用示例：
    224          ********************************************************************************/

   \                                 In  segment CODE, align 2, keep-with-next
    225          void NRF2401_SetTXMode(void)
   \                     NRF2401_SetTXMode:
    226          {				
    227          	NRF2401_CE=0;
   \   000000   ........     CALLA   #?Subroutine5
    228           
    229          	NRF2401_ReadWriteReg(WRITE_REG+CONFIG,0x0e);    //配置基本工作模式的参数;PWR_UP,EN_CRC,16BIT_CRC,接收模式,开启所有中断
   \                     ??CrossCallReturnLabel_9:
   \   000004   7D400E00     MOV.B   #0xe, R13
   \   000008   ....         JMP     ?Subroutine0
   \   00000A   0343         NOP
   \   00000C                REQUIRE _A_PBOUT_L
    230          	
    231                  NRF2401_CE=1;//CE为高,10us后启动发送
    232          }
    233          /*******************************************************************************
    234          *  函数名称：
    235          *  功能说明：启动NRF24L01发送一次数据
    236          *  参数说明：txbuf:待发送数据首地址
    237          *  函数返回：返回值:发送完成状况
    238          *  使用示例：
    239          ********************************************************************************/

   \                                 In  segment CODE, align 2
    240          void NRF2401_SendData(uint8_t *txbuf)
   \                     NRF2401_SendData:
    241          {
    242          	/*uint8_t sta;
    243          	NRF2401_CE=0;
    244          	NRF2401_WriteBuffer(WR_TX_PLOAD,txbuf,TX_PLOAD_WIDTH);//写数据到TX BUF  32个字节
    245           	NRF2401_CE=1;//启动发送	  
    246          	while(NRF2401_IRQ!=0);//等待发送完成
    247          	sta = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值	
    248          	NRF2401_ReadWriteReg(WRITE_REG+STATUS,sta); //清除TX_DS或MAX_RT中断标志
    249          	
    250          	if(sta & MAX_TX)//达到最大重发次数
    251          	{
    252          		NRF2401_ReadWriteReg(FLUSH_TX,0xff);//清除TX FIFO寄存器 
    253          		return MAX_TX; 
    254          	}
    255          	if(sta & TX_OK)//发送完成
    256          	{
    257          		return TX_OK;
    258          	}
    259          	return 0xff;//其他原因发送失败
    260                  */
    261                  NRF2401_CE = 0;			//StandBy I模式	
   \   000000   ........     CALLA   #?Subroutine5
    262                  
    263          	NRF2401_WriteBuffer(WR_TX_PLOAD, txbuf, TX_PLOAD_WIDTH); 			 // 装载数据	
   \                     ??CrossCallReturnLabel_10:
   \   000004   7E402000     MOV.B   #0x20, R14
   \   000008   CD0C         MOVA    R12, R13
   \   00000A   7C40A000     MOV.B   #0xa0, R12
   \   00000E   ........     CALLA   #NRF2401_WriteBuffer
    264                  NRF2401_ReadWriteReg(WRITE_REG+STATUS,STATUS_TX_DS|STATUS_MAX_RT); //清除TX_DS或MAX_RT中断标志
   \   000012   7D403000     MOV.B   #0x30, R13
   \   000016   7C402700     MOV.B   #0x27, R12
   \   00001A   ....         JMP     ??Subroutine6_0
   \   00001C   0343         NOP
   \   00001E                REQUIRE _A_PBOUT_L
    265                  
    266                  NRF2401_CE = 1;		 //置高CE，激发数据发送
    267          }
    268          /*******************************************************************************
    269          *  函数名称：
    270          *  功能说明：启动NRF24L01发送一次数据
    271          *  参数说明：txbuf:待发送数据首地址
    272          *  函数返回：返回值:0，接收完成；其他，错误代码
    273          *  使用示例：
    274          ********************************************************************************/

   \                                 In  segment CODE, align 2
    275          uint8_t NRF2401_RecData(uint8_t *rxbuf)
   \                     NRF2401_RecData:
    276          {
   \   000000   1B14         PUSHM.A #0x2, R11
   \   000002   CA0C         MOVA    R12, R10
    277          	uint8_t status = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值    	 
   \   000004   7D43         MOV.B   #0xff, R13
   \   000006   7C400700     MOV.B   #0x7, R12
   \   00000A   ........     CALLA   #NRF2401_ReadWriteReg
   \   00000E   4B4C         MOV.B   R12, R11
    278          	NRF2401_ReadWriteReg(WRITE_REG+STATUS,status); //清除TX_DS或MAX_RT中断标志
   \   000010   4D4C         MOV.B   R12, R13
   \   000012   7C402700     MOV.B   #0x27, R12
   \   000016   ........     CALLA   #NRF2401_ReadWriteReg
    279                  if(status & RX_OK)//接收到数据
   \   00001A   7BB04000     BIT.B   #0x40, R11
   \   00001E   0F24         JEQ     ??NRF2401_RecData_0
    280          	{
    281          		NRF2401_ReadBuffer(RD_RX_PLOAD,rxbuf,RX_PLOAD_WIDTH);//读取数据
   \   000020   7E402000     MOV.B   #0x20, R14
   \   000024   CD0A         MOVA    R10, R13
   \   000026   7C406100     MOV.B   #0x61, R12
   \   00002A   ........     CALLA   #NRF2401_ReadBuffer
    282          		NRF2401_ReadWriteReg(FLUSH_RX,0xff);//清除RX FIFO寄存器 
   \   00002E   7D43         MOV.B   #0xff, R13
   \   000030   7C40E200     MOV.B   #0xe2, R12
   \   000034   ........     CALLA   #NRF2401_ReadWriteReg
    283          		return RX_OK; 
   \   000038   7C404000     MOV.B   #0x40, R12
   \   00003C   013C         JMP     ??NRF2401_RecData_1
    284          	}   
    285          	return 0xff;//没收到任何数据
   \                     ??NRF2401_RecData_0:
   \   00003E   7C43         MOV.B   #0xff, R12
   \                     ??NRF2401_RecData_1:
   \   000040   1A16         POPM.A  #0x2, R11
   \   000042   1001         RETA
    286          }
    287          /*******************************************************************************
    288          *  函数名称：
    289          *  功能说明：NRF24L01中断处理函数，请在中断中添加该函数
    290          *  参数说明：
    291          *  函数返回：
    292          *  使用示例：
    293          ********************************************************************************/

   \                                 In  segment CODE, align 2
    294          void  NRF2401_IRQ_Handler()
   \                     NRF2401_IRQ_Handler:
    295          {
   \   000000   5B14         PUSHM.A #0x6, R11
    296              /*读取status寄存器的值  */
    297              uint8_t state = NRF2401_ReadWriteReg(STATUS,0xFF);  //读取状态寄存器的值   
   \   000002   3A406302     MOV.W   #0x263, R10
   \   000006   0F4A         MOV.W   R10, R15
   \   000008   EFC20000     BIC.B   #0x4, 0(R15)
   \   00000C   ........     MOVA    #SPI_SendReadByte, R11
   \   000010   78400300     MOV.B   #0x3, R8
   \   000014   7D400700     MOV.B   #0x7, R13
   \   000018   4C48         MOV.B   R8, R12
   \   00001A   4B13         CALLA   R11
   \   00001C   494C         MOV.B   R12, R9
   \   00001E   ........     CALLA   #??Subroutine7_0
    298              if(state & STATUS_RX_DR) //接收到数据
   \                     ??CrossCallReturnLabel_13:
   \   000022   ........     MOVA    #s_nrf24l01, R6
   \   000026   79B04000     BIT.B   #0x40, R9
   \   00002A   1A24         JEQ     ??NRF2401_IRQ_Handler_3
    299              {
    300                 NRF2401_CE = 0;			//StandBy I模式	
   \   00002C   ........     CALLA   #?Subroutine5
    301                 if(s_nrf24l01.CallBack_RecevieData != NULL)
   \                     ??CrossCallReturnLabel_11:
   \   000030   3F060800     MOVA    0x8(R6), R15
   \   000034   DF03         CMPA    #0x0, R15
   \   000036   0A24         JEQ     ??NRF2401_IRQ_Handler_4
    302                 {
    303                    NRF2401_ReadBuffer(RD_RX_PLOAD,(uint8_t *)s_nrf24l01.pReceiveData,RX_PLOAD_WIDTH);//读取数据
   \   000038   7E402000     MOV.B   #0x20, R14
   \   00003C   0D06         MOVA    @R6, R13
   \   00003E   7C406100     MOV.B   #0x61, R12
   \   000042   ........     CALLA   #NRF2401_ReadBuffer
    304                    s_nrf24l01.CallBack_RecevieData();
   \   000046   3F060800     MOVA    0x8(R6), R15
   \   00004A   4F13         CALLA   R15
    305                 }
    306                 NRF2401_ReadWriteReg(FLUSH_RX,0xff);//清除RX FIFO寄存器 
   \                     ??NRF2401_IRQ_Handler_4:
   \   00004C   0F4A         MOV.W   R10, R15
   \   00004E   EFC20000     BIC.B   #0x4, 0(R15)
   \   000052   7D40E200     MOV.B   #0xe2, R13
   \   000056   ........     CALLA   #?Subroutine4
    307                 NRF2401_CE = 1;		 //置高CE，激发数据发送
   \                     ??CrossCallReturnLabel_12:
   \   00005A   F2D080002202 BIS.B   #0x80, &0x222
    308              }
    309          
    310              if(state & STATUS_TX_DS) //发送完数据
   \                     ??NRF2401_IRQ_Handler_3:
   \   000060   79B02000     BIT.B   #0x20, R9
   \   000064   0524         JEQ     ??NRF2401_IRQ_Handler_2
    311              {
    312                  if(s_nrf24l01.CallBack_SendDataOk != NULL)
   \   000066   3F060C00     MOVA    0xc(R6), R15
   \   00006A   DF03         CMPA    #0x0, R15
   \   00006C   0124         JEQ     ??NRF2401_IRQ_Handler_2
    313                  {
    314                    s_nrf24l01.CallBack_SendDataOk();
   \   00006E   4F13         CALLA   R15
    315                  }
    316              }
    317          
    318              if(state & STATUS_MAX_RT)      //发送超时
   \                     ??NRF2401_IRQ_Handler_2:
   \   000070   79B01000     BIT.B   #0x10, R9
   \   000074   0C24         JEQ     ??NRF2401_IRQ_Handler_1
    319              {
    320                  if(s_nrf24l01.CallBack_SendOutTime != NULL)
   \   000076   3F061000     MOVA    0x10(R6), R15
   \   00007A   DF03         CMPA    #0x0, R15
   \   00007C   0124         JEQ     ??NRF2401_IRQ_Handler_5
    321                  {
    322                     s_nrf24l01.CallBack_SendOutTime();
   \   00007E   4F13         CALLA   R15
    323                  }
    324                  NRF2401_ReadWriteReg(FLUSH_TX,0xff);//清除TX FIFO寄存器
   \                     ??NRF2401_IRQ_Handler_5:
   \   000080   0F4A         MOV.W   R10, R15
   \   000082   EFC20000     BIC.B   #0x4, 0(R15)
   \   000086   7D40E100     MOV.B   #0xe1, R13
   \   00008A   ........     CALLA   #?Subroutine4
    325              }
    326          
    327              if(state & STATUS_TX_FULL) //TX FIFO 满
   \                     ??NRF2401_IRQ_Handler_1:
   \   00008E   59B3         BIT.B   #0x1, R9
   \   000090   0524         JEQ     ??NRF2401_IRQ_Handler_0
    328              {
    329                  if(s_nrf24l01.CallBack_TxFull != NULL)
   \   000092   3F061400     MOVA    0x14(R6), R15
   \   000096   DF03         CMPA    #0x0, R15
   \   000098   0124         JEQ     ??NRF2401_IRQ_Handler_0
    330                  {
    331                     s_nrf24l01.CallBack_TxFull();
   \   00009A   4F13         CALLA   R15
    332                  }
    333              }
    334              NRF2401_ReadWriteReg(WRITE_REG+STATUS,state); //清除TX_DS或MAX_RT中断标志
   \                     ??NRF2401_IRQ_Handler_0:
   \   00009C   0F4A         MOV.W   R10, R15
   \   00009E   EFC20000     BIC.B   #0x4, 0(R15)
   \   0000A2   7D402700     MOV.B   #0x27, R13
   \   0000A6   4C48         MOV.B   R8, R12
   \   0000A8   4B13         CALLA   R11
   \   0000AA   4D49         MOV.B   R9, R13
   \   0000AC   4C48         MOV.B   R8, R12
   \   0000AE   4B13         CALLA   R11
   \   0000B0   EAD20000     BIS.B   #0x4, 0(R10)
    335          }
   \   0000B4   5616         POPM.A  #0x6, R11
   \   0000B6   1001         RETA
   \   0000B8                REQUIRE _A_PBOUT_L
   \   0000B8                REQUIRE _A_PDOUT_L

   \                                 In  segment CODE, align 2, keep-with-next
   \                     ?Subroutine4:
   \   000000   4C48         MOV.B   R8, R12
   \   000002   4B13         CALLA   R11
   \   000004                REQUIRE ??Subroutine7_0
   \   000004                // Fall through to label ??Subroutine7_0

   \                                 In  segment CODE, align 2
   \                     ??Subroutine7_0:
   \   000000   7D43         MOV.B   #0xff, R13
   \   000002   4C48         MOV.B   R8, R12
   \   000004   4B13         CALLA   R11
   \   000006   0F4A         MOV.W   R10, R15
   \   000008   EFD20000     BIS.B   #0x4, 0(R15)
   \   00000C   1001         RETA

   \                                 In  segment DATA20_C, align 1, align-sorted
   \                     `?<Constant {165, 165, 165, 165, 165}>`:
   \   000000   A5A5A5A5A5   DC8 165, 165, 165, 165, 165
    336          
    337          

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
     28   NRF2401_IRQ_Handler
       28   -- Indirect call
       28   -> NRF2401_ReadBuffer
       28   -> SPI_SendReadByte
       32   -> SPI_SendReadByte
     30   NRF2401_Init
       26   -- Indirect call
       26   -> GPIO_MultiBits_Init
       30   -> NRF2401_ReadBuffer
       26   -> NRF2401_ReadWriteReg
       26   -> NRF2401_WriteBuffer
       30   -> NRF2401_WriteBuffer
       30   -> SPI_Master_Init
       26 ?CopyMemoryWords20
     20   NRF2401_ReadBuffer
       20   -> SPI_SendReadByte
       24   -> SPI_SendReadByte
     12   NRF2401_ReadWriteReg
       12   -> SPI_SendReadByte
     12   NRF2401_RecData
       12   -> NRF2401_ReadBuffer
       12   -> NRF2401_ReadWriteReg
      4   NRF2401_SendData
        4   -> NRF2401_ReadWriteReg
        4   -> NRF2401_WriteBuffer
      4   NRF2401_SetRXMode
        4   -> NRF2401_ReadWriteReg
      4   NRF2401_SetTXMode
        4   -> NRF2401_ReadWriteReg
     20   NRF2401_WriteBuffer
       20   -> SPI_SendReadByte
       24   -> SPI_SendReadByte


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       5  ?<Constant {165, 165, 165, 165, 165}>
      12  ??Subroutine6_0
      14  ??Subroutine7_0
       4  ?Subroutine0
      10  ?Subroutine1
      24  ?Subroutine2
       8  ?Subroutine3
       4  ?Subroutine4
       8  ?Subroutine5
     184  NRF2401_IRQ_Handler
     314  NRF2401_Init
      30  NRF2401_ReadBuffer
      32  NRF2401_ReadWriteReg
      68  NRF2401_RecData
      30  NRF2401_SendData
       8  NRF2401_SetRXMode
      12  NRF2401_SetTXMode
      18  NRF2401_WriteBuffer
       5  RX_ADDRESS
       5  TX_ADDRESS
       2  _A_PBOUT_L
       2  _A_PDOUT_L
      24  s_nrf24l01

 
 780 bytes in segment CODE
   4 bytes in segment DATA16_AN
  15 bytes in segment DATA20_C
  24 bytes in segment DATA20_Z
 
 780 bytes of CODE  memory
  15 bytes of CONST memory
  24 bytes of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: none
